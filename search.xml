<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[从浏览器输入一个地址到渲染出网页的过程]]></title>
      <url>%2F2017%2F06%2F14%2Fnet-process%2F</url>
      <content type="text"><![CDATA[http://abc.com:80/z/c?i=1#bhttp协议 uri 端口号 路径 参数 片段 域名通过dns解析成ip 首先查询浏览器缓存 再查询系统缓存 再递归查询dns服务器 建立tcp链接，三次握手 syn-》 《- syn/ack ack -》 http报文生成 报文首部 请求行 PUT example.html HTTP1.1 请求首部字段：Accept等 报文体 包装报文，经过链路层（mac），传输层（tcp），网络层（ip），应用层（http） 服务器接收到HTTP请求 服务器接收到数据之后，会经过链路层，网络层，传输层逐层将该层对应的首部信息去掉 7． 服务器根据收到的HTTP数据，生成对应的响应报文,结构如下： 状态行：由HTTP 版本 状态码 原因短语构成 响应首部字段 通用首部字段 实体首部字段 都可以查手册得知其具体内容以及含义这里不再展开 客户端接收到了响应报文之后，浏览器渲染呈现 浏览器通常的主要组件分为以下几部分： 用户界面：如地址栏 书签菜单等等 浏览器引擎：在用户界面和呈现引擎之间传送之类 呈现引擎：负责显示请求的内容。例如HTMLhe CSS JAVAScript解释器：用于解释和执行JavaScript 代码 数据存储 渲染文档主要使用呈现引擎。过程如下： 呈现引擎从网络层获取请求文档的内容HTML文件，内容大小一般在8000个块以内。 引擎解析HTML文档 将各个标记转化为内容树上的DOM节点 ，同时解析CSS文件 样式数据 样式信息和 内容树共同构建成为 呈现树 呈现树构建完毕以后，进入布局阶段， 为每一个节点分配一个应该出现在屏幕上的确切坐标 呈现引擎遍历呈现树 由用户界面后端层将每个节点绘制出来。 参考链接1 参考链接2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this的四种用法]]></title>
      <url>%2F2017%2F06%2F14%2Fthis%2F</url>
      <content type="text"><![CDATA[在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。在《javaScript语言精粹》这本书中，把 this出现的场景分为四类，简单的说就是：有对象就指向调用对象,没调用对象就指向全局对象,用new构造就指向新对象，通过 apply 或 call 或 bind 来改变 this 的所指。 1. 函数有所属对象时：指向所属对象函数有所属对象时，通常通过 . 表达式调用，这时 this自然指向所属对象。比如下面的例子：12345678var myObject = &#123;value: 100&#125;;myObject.getValue = function () &#123; console.log(this.value); // 输出 100 console.log(this);// 输出 &#123; value: 100, getValue: [Function] &#125;， // 其实就是 myObject 对象本身 return this.value;&#125;;console.log(myObject.getValue()); // =&gt; 100 getValue() 属于对象 myObject，并由 myOjbect 进行 . 调用，因此 this 指向对象 myObject。 2. 函数没有所属对象：指向全局对象12345678910var myObject = &#123;value: 100&#125;;myObject.getValue = function () &#123; var foo = function () &#123; console.log(this);// 输出全局对象 global console.log(this.value) // =&gt; undefined &#125;; foo(); return this.value;&#125;;console.log(myObject.getValue()); // =&gt; 100 在上述代码块中，foo 函数虽然定义在 getValue的函数体内，但实际上它既不属于 getValue 也不属于 myObject。foo 并没有被绑定在任何对象上，所以当调用时，它的 this 指针指向了全局对象 global。据说这是个设计错误。 3. 构造器中的 this：指向新对象js 中，我们通过 new 关键词来调用构造函数，此时 this会绑定在该新对象上。12345var SomeClass = function()&#123; this.value = 100;&#125;var myCreate = new SomeClass();console.log(myCreate.value); // 输出100 顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。 4. apply 和 call 调用以及 bind 绑定：指向绑定的对象 apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。 call() 方法第一个参数的意义与apply()方法相同，只是其他的参数需要一个个列举出来。简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。123456789var myObject = &#123;value: 100&#125;;var foo = function()&#123; console.log(this);&#125;;foo(); // 全局变量 globalfoo.apply(myObject); // &#123; value: 100 &#125;foo.call(myObject); // &#123; value: 100 &#125;var newFoo = foo.bind(myObject);newFoo(); // &#123; value: 100 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript 6 变量解构赋值]]></title>
      <url>%2F2016%2F12%2F06%2Fdestructuring%2F</url>
      <content type="text"><![CDATA[为什么解构很有用ECMAScript 5以及以前的版本:1234567let options = &#123; repeat: true, save: false&#125;;// extract data from the objectlet repeat = options.repeat, save = options.save; 虽然这段代码看上去也挺简单的,但想象一下如果你要给大量的变量赋值,你得一个一个的赋值。或者你需要取一个嵌套结构数据的某个值,也许你得遍历整个结构。如果你能把数据解构成一些小小的片段,那获取信息将会更加容易。 对象的解构1234567let node = &#123; type: "Identifier", name: "foo"&#125;;let &#123; type, name &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo" 注意: 必须初始化123456// syntax error!var &#123; type, name &#125;;// syntax error!let &#123; type, name &#125;;// syntax error!const &#123; type, name &#125;; 解构赋值可以赋值给已经定义过的变量:12345678910let node = &#123; type: "Identifier", name: "foo"&#125;,type = "Literal",name = 5;// assign different values using destructuring(&#123; type, name &#125; = node);console.log(type); // "Identifier"console.log(name); // "foo" 默认值12345678let node = &#123; type: "Identifier", name: "foo"&#125;;let &#123; type, name, value = true &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // true 给不同名本地变量赋值1234567let node = &#123; type: "Identifier", name: "foo"&#125;;let &#123; type: localType, name: localName &#125; = node;console.log(localType); // "Identifier"console.log(localName); // "foo" 嵌套对象解构1234567891011121314151617let node = &#123; type: "Identifier", name: "foo", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125; &#125;;let &#123; loc: &#123; start &#125;&#125; = node;console.log(start.line); // 1console.log(start.column); // 1 数组的解构1234let colors = [ "red", "green", "blue" ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 只取你需要的部分123let colors = [ "red", "green", "blue" ];let [ , , thirdColor ] = colors;console.log(thirdColor); // "blue" 注意: 和对象的解构一样,必须初始化 解构赋值可以赋值给已经定义过的变量:123456let colors = [ "red", "green", "blue" ], firstColor = "black", secondColor = "purple";[ firstColor, secondColor ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 在ECMAScript 5 中交换变量值1234567let a = 1, b = 2, tmp;tmp = a;a = b;b = tmp;console.log(a); // 2console.log(b); // 1 在ECMAScript 6 中交换变量值12345let a = 1, b = 2;[ a, b ] = [ b, a ];console.log(a); // 2console.log(b); // 1 默认值1234let colors = [ "red" ];let [ firstColor, secondColor = "green" ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 嵌套数组解构12345let colors = [ "red", [ "green", "lightgreen" ], "blue" ];// laterlet [ firstColor, [ secondColor ] ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 剩余的元素123456let colors = [ "red", "green", "blue" ];let [ firstColor, ...restColors ] = colors;console.log(firstColor); // "red"console.log(restColors.length); // 2console.log(restColors[0]); // "green"console.log(restColors[1]); // "blue" 数组的第一个值赋给了firstColor,剩下的值组成了一个新的数组赋给了restColors。 ECMAScript 5克隆一个数组:123var colors = [ "red", "green", "blue" ];var clonedColors = colors.concat();console.log(clonedColors); // "[red,green,blue]" ECMAScript 6克隆一个数组:123let colors = [ "red", "green", "blue" ];let [ ...clonedColors ] = colors;console.log(clonedColors); // "[red,green,blue]" 注意: 剩余的元素必须是解构数组的最后一个元素,后面不能有逗号。 混合解构对象与数组嵌套混合的解构:1234567891011121314151617181920let node = &#123; type: "Identifier", name: "foo", loc: &#123; start: &#123; line: 1,column: 1 &#125;, end: &#123; line: 1,column: 4 &#125;&#125;, range: [0, 3]&#125;;let &#123; loc: &#123; start &#125;, range: [ startIndex ]&#125; = node;console.log(start.line); // 1console.log(start.column); // 1console.log(startIndex); // 0 参数解构1234567function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123; // code to set the cookie&#125;setCookie("type", "js", &#123; secure: true, expires: 60000&#125;); 解构的参数是必需的12// error!setCookie("type", "js"); 它实际上是这样运行的:1234function setCookie(name, value, options) &#123; let &#123; secure, path, domain, expires &#125; = options; // code to set the cookie&#125; 当解构赋值的右边是null或者undefined,就会抛出错误。 如果你希望解构参数是可选的,你可以这样写:12function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // empty &#125; 解构参数的默认值12345678function setCookie(name, value, &#123; secure = false, path = "/", domain = "example.com", expires = new Date(Date.now() + 360000000)&#125; = &#123;&#125; )&#123;// empty &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node连接mysql数据库实例]]></title>
      <url>%2F2016%2F11%2F18%2Fnode-mysql%2F</url>
      <content type="text"><![CDATA[Express生成应用首先假定你已经安装了Node.js，接下来通过应用生成器工具 express 可以快速创建一个应用的骨架。通过如下命令安装express和express-generator：12$ npm install express -g$ npm install express-generator -g 当前工作目录下创建一个命名为 myapp 的应用:12345678910111213141516171819$ express myapp create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.jade create : myapp/views/layout.jade create : myapp/views/error.jade create : myapp/bin create : myapp/bin/www 然后安装所有依赖包： 12$ cd myapp $ npm install 启动这个应用（MacOS 或 Linux 平台）： 1$ DEBUG=myapp npm start Windows 平台使用如下命令： 1&gt; set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。通过 Express 应用生成器创建的应用一般都有如下目录结构：12345678910111213141516171819.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.jade ├── index.jade └── layout.jade7 directories, 9 files MySQL数据库连接本地数据库安装navicat和MySQL。进入【系统偏好设置】启动本地mysql服务:在navicat中连接本地数据库: 创建数据库创建一个测试数据库nodesample，在数据库中建一个userinfo表12345678910111213CREATE DATABASE IF NOT EXISTS nodesample CHARACTER SET UTF8;USE nodesample; SET FOREIGN_KEY_CHECKS=0;DROP TABLE IF EXISTS `userinfo`;CREATE TABLE `userinfo` (`Id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',`UserName` varchar(64) NOT NULL COMMENT '用户名',`UserPass` varchar(64) NOT NULL COMMENT '用户密码',PRIMARY KEY (`Id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表'; node连接数据库Node.js与MySQL交互操作有很多库,这里选择felixge/node-mysql。安装mysql模块1$ npm install mysql --save 打开routes/users.js,引入mysql模块1var mysql = require('mysql'); 建立连接123456789101112131415var connection = mysql.createConnection(&#123; host: '127.0.0.1', user: 'root', password: '123', port: '3306', database: 'nodesample'&#125;);connection.connect(function(err)&#123; if(!err) &#123; console.log("Database is connected ... nn"); &#125; else &#123; console.log("Error connecting database ... nn"); &#125;&#125;); 实现RESTFUL接口 增 1234567891011/* * PUT to updateuser. */router.put('/updateuser/:id', function(req, res) &#123; var userUpSql = 'UPDATE userinfo SET ? WHERE Id='+req.params.id; connection.query(userUpSql, req.body, function(err, result) &#123; res.send( (err === null) ? &#123; msg: '' &#125; : &#123; msg: err &#125; ); &#125;);&#125;); 删 123456789/* * DELETE to deleteuser. */router.delete('/deleteuser/:id', function(req, res) &#123; var userDelSql = 'DELETE FROM userinfo where Id='+req.params.id; connection.query(userDelSql, function (err, result) &#123; res.send((err === null) ? &#123; msg: '' &#125; : &#123; msg:'error: ' + err &#125;); &#125;);&#125;); 改 12345678910/* * POST to adduser. */router.post('/adduser', function(req, res) &#123; connection.query('INSERT INTO userinfo SET ?', req.body, function(err, result) &#123; res.send( (err === null) ? &#123; msg: '' &#125; : &#123; msg: err &#125; ); &#125;);&#125;); 查 123456789/* GET users listing. */router.get("/userlist",function(req,res)&#123; connection.query('SELECT * from userinfo', function(err, rows, fields) &#123; if (!err) res.json(rows); else console.log('Error while performing Query.'); &#125;);&#125;); 画页面在public/javascripts中新建global.js,并打开views/layout.jade,在末尾引入jquery和global.js。12script(src=&apos;http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js&apos;)script(src=&apos;/javascripts/global.js&apos;) 打开views/index.jade,写好页面结构:123456789101112131415161718192021222324252627282930313233343536373839404142434445extends layoutblock content // Wrapper #wrapper // USER INFO #userInfo h2 User Info p strong Name: | &lt;span id=&apos;UserName&apos;&gt;&lt;/span&gt; br strong Pass: | &lt;span id=&apos;UserPass&apos;&gt;&lt;/span&gt; // /USER INFO // USER LIST h2 User List #userList table thead th UserName th UserPass th Delete? th Edit? tbody // /USER LIST // ADD USER h2 Add User #addUser fieldset input#inputUserName(type=&apos;text&apos;, placeholder=&apos;Username&apos;) input#inputUserPass(type=&apos;text&apos;, placeholder=&apos;UserPass&apos;) br button#btnAddUser Add User // /ADD USER .mask #upUser.alert fieldset input#modId(type=&apos;hidden&apos;) input#modUserName(type=&apos;text&apos;, placeholder=&apos;Username&apos;) input#modUserPass(type=&apos;text&apos;, placeholder=&apos;UserPass&apos;) br button#btnModUser Modify User 样式写在public/stylesheets/style.css里,可以看我放到github上的源码。 调用接口在上面新建的global.js里编写调用接口的代码 查数据并画表格 123456789101112131415function populateTable() &#123; var tableContent = ''; $.getJSON( '/users/userlist', function( data ) &#123; userListData = data; $.each(data, function()&#123; tableContent += '&lt;tr&gt;'; tableContent += '&lt;td&gt;&lt;a href="#" class="linkshowuser" rel="' + this.UserName + '" title="Show Details"&gt;' + this.UserName + '&lt;/a&gt;&lt;/td&gt;'; tableContent += '&lt;td&gt;' + this.UserPass + '&lt;/td&gt;'; tableContent += '&lt;td&gt;&lt;a href="#" class="linkdeleteuser" rel="' + this.Id + '"&gt;delete&lt;/a&gt;&lt;/td&gt;'; tableContent += '&lt;td&gt;&lt;a href="#" class="linkupdateuser" rel="' + this.Id + '"&gt;edit&lt;/a&gt;&lt;/td&gt;'; tableContent += '&lt;/tr&gt;'; &#125;); $('#userList table tbody').html(tableContent); &#125;);&#125;; 增 12345678910111213141516171819202122232425262728293031323334function addUser(event) &#123; event.preventDefault(); // 每个输入框必填 var errorCount = 0; $('#addUser input').each(function(index, val) &#123; if($(this).val() === '') &#123; errorCount++; &#125; &#125;); if(errorCount === 0) &#123; var newUser = &#123; 'UserName': $('#addUser fieldset input#inputUserName').val(), 'UserPass': $('#addUser fieldset input#inputUserPass').val() &#125;; $.ajax(&#123; type: 'POST', url: '/users/adduser', data: newUser, dataType: 'JSON' &#125;).done(function( response ) &#123; if (response.msg === '') &#123; // Clear the form inputs $('#addUser fieldset input').val(''); // Update the table populateTable(); &#125; else &#123; alert('Error: ' + response.msg); &#125; &#125;); &#125; else &#123; alert('Please fill in all fields'); return false; &#125;&#125;; 删 1234567891011121314151617181920212223function deleteUser(event) &#123; event.preventDefault(); // 确定删除吗 var confirmation = confirm('Are you sure you want to delete this user?'); if (confirmation === true) &#123; $.ajax(&#123; type: 'DELETE', url: '/users/deleteuser/' + $(this).attr('rel') &#125;).done(function( response ) &#123; if (response.msg === '') &#123; &#125; else &#123; alert('Error: ' + response.msg); &#125; populateTable(); &#125;); &#125; else &#123; return false; &#125;&#125;; 改 1234567891011121314151617181920212223242526272829303132function updateUser(event) &#123; event.preventDefault(); // 每个输入框必填 var errorCount = 0; $('#upUser input').each(function(index, val) &#123; if($(this).val() === '') &#123; errorCount++; &#125; &#125;); if(errorCount === 0) &#123; var upUser = &#123; 'UserName': $('#upUser fieldset input#modUserName').val(), 'UserPass': $('#upUser fieldset input#modUserPass').val() &#125;; $.ajax(&#123; type: 'PUT', url: '/users/updateuser/' + $('#upUser fieldset input#modId').val(), data: upUser, dataType: 'JSON' &#125;).done(function( response ) &#123; if (response.msg === '') &#123; $('.mask').hide(); $('.alert').hide(); populateTable(); &#125; else &#123; alert('Error: ' + response.msg); &#125; &#125;); &#125; else &#123; return false; &#125;&#125;; 完整的代码可以去github上查看,以下是最终效果: 参考文章express用NODE.JS,EXPRESS,MONGODB创建一个简单的RESTFUL WEB APP express中文网 mysql与nodeNodejs学习笔记(四)与MySQL交互(felixge/node-mysql) Node.js and MySQL tutorial]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中Math.random()的使用和扩展]]></title>
      <url>%2F2016%2F09%2F21%2Fjs-random%2F</url>
      <content type="text"><![CDATA[Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。 在连续整数中取得一个随机数1值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 例：产生1-10的随机数1var rand1 = Math.floor(Math.random() * 10 + 1); 编写产生startNumber至endNumber随机数的函数12345function selectFrom(startNumber, endNumber) &#123; var choice = endNumber - startNumber + 1; return Math.floor(Math.random() * choice + startNumber)&#125;var rand2 = selectFrom(2,8);//产生2至8的随机数 在不相邻整数中取得一个随机数在不相邻的两个整数中取得一个随机数例：随机产生2或4中的一个数1var rand3 = Math.random() &lt; 0.5 ? 2 : 4; 在不相邻的多个整数中产生一个随机数结合函数参数数组，可编写在不相邻的多个整数中产生一个随机值的函数12345678function selectFromMess() &#123; return arguments[Math.floor(Math.random() * arguments.length)]&#125;//随机产生1、6、8中的一个数var rand4 = selectFromMess(1, 6, 8);//也可随机产生文本var randomTxt1 = selectFromMess("安慰奖", "二等奖", "一等奖"); 每次要输入这么多参数比较麻烦，可以改写一下函数12345function selectFromMessArray(arr) &#123; return arr[Math.floor(Math.random() * arr.length)]&#125;var arrayTxt=["一","二","三","四","五"];var randTxt2 = selectFromMessArray(arrayTxt); 或者不改变原有方法，可以利用apply()这个方法传递数组参数1var randTxt3 = selectFromMess.apply(null,arrayTxt); 关于apply方法的使用可以看这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将本地仓库提交到github上]]></title>
      <url>%2F2016%2F09%2F19%2Fgit-command%2F</url>
      <content type="text"><![CDATA[先在github上新建一个仓库,取名,例test 本地新建文件夹 打开命令行工具cd进这个文件夹 执行git init,执行后会在该文件夹下生成一个名为.git的文件夹,里面有有关git的配置 关联到远程仓库git remote add origin https://YehanZhou@github.com/YehanZhou/test.git 添加所有文件到暂存区git add . 提交git commit -m &quot;description&quot; 推送git push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo命令]]></title>
      <url>%2F2016%2F09%2F18%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
